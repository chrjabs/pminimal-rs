From fa156745a153e6603c7c7ce16f1cd0db8bfb087d Mon Sep 17 00:00:00 2001
From: Christoph Jabs <christoph.jabs@helsinki.fi>
Date: Fri, 13 Sep 2024 10:37:13 +0300
Subject: [PATCH] perf: disable finalize

---
 src/internal.cpp | 85 ++++++++++++++++++++++++------------------------
 1 file changed, 43 insertions(+), 42 deletions(-)

diff --git a/src/internal.cpp b/src/internal.cpp
index d524edd..55ec3c9 100644
--- a/src/internal.cpp
+++ b/src/internal.cpp
@@ -47,7 +47,7 @@ Internal::Internal ()
 }
 
 Internal::~Internal () {
-  delete[](char *) dummy_binary;
+  delete[] (char *) dummy_binary;
   for (const auto &c : clauses)
     delete_clause (c);
   if (proof)
@@ -841,47 +841,48 @@ void Internal::finalize (int res) {
   if (!proof)
     return;
   LOG ("finalizing");
-  // finalize external units
-  for (const auto &evar : external->vars) {
-    assert (evar > 0);
-    const auto eidx = 2 * evar;
-    int sign = 1;
-    uint64_t id = external->ext_units[eidx];
-    if (!id) {
-      sign = -1;
-      id = external->ext_units[eidx + 1];
-    }
-    if (id) {
-      proof->finalize_external_unit (id, evar * sign);
-    }
-  }
-  // finalize internal units
-  for (const auto &lit : lits) {
-    const auto elit = externalize (lit);
-    if (elit) {
-      const unsigned eidx = (elit < 0) + 2u * (unsigned) abs (elit);
-      const uint64_t id = external->ext_units[eidx];
-      if (id) {
-        assert (unit_clauses[vlit (lit)] == id);
-        continue;
-      }
-    }
-    const auto uidx = vlit (lit);
-    const uint64_t id = unit_clauses[uidx];
-    if (!id)
-      continue;
-    proof->finalize_unit (id, lit);
-  }
-  // See the discussion in 'propagate' on why garbage binary clauses stick
-  // around.
-  for (const auto &c : clauses)
-    if (!c->garbage || c->size == 2)
-      proof->finalize_clause (c);
-
-  // finalize conflict and proof
-  if (conflict_id) {
-    proof->finalize_clause (conflict_id, {});
-  }
+  // // finalize external units
+  // for (const auto &evar : external->vars) {
+  //   assert (evar > 0);
+  //   const auto eidx = 2 * evar;
+  //   int sign = 1;
+  //   uint64_t id = external->ext_units[eidx];
+  //   if (!id) {
+  //     sign = -1;
+  //     id = external->ext_units[eidx + 1];
+  //   }
+  //   if (id) {
+  //     proof->finalize_external_unit (id, evar * sign);
+  //   }
+  // }
+  // // finalize internal units
+  // for (const auto &lit : lits) {
+  //   const auto elit = externalize (lit);
+  //   if (elit) {
+  //     const unsigned eidx = (elit < 0) + 2u * (unsigned) abs (elit);
+  //     const uint64_t id = external->ext_units[eidx];
+  //     if (id) {
+  //       assert (unit_clauses[vlit (lit)] == id);
+  //       continue;
+  //     }
+  //   }
+  //   const auto uidx = vlit (lit);
+  //   const uint64_t id = unit_clauses[uidx];
+  //   if (!id)
+  //     continue;
+  //   proof->finalize_unit (id, lit);
+  // }
+  // // See the discussion in 'propagate' on why garbage binary clauses
+  // stick
+  // // around.
+  // for (const auto &c : clauses)
+  //   if (!c->garbage || c->size == 2)
+  //     proof->finalize_clause (c);
+
+  // // finalize conflict and proof
+  // if (conflict_id) {
+  //   proof->finalize_clause (conflict_id, {});
+  // }
   proof->report_status (res, conflict_id);
   if (res == 10)
     external->conclude_sat ();
-- 
2.46.0

